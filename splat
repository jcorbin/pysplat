#!/usr/bin/env pypy

import errno
import fileinput
import os
import sys
from collections import OrderedDict, Sequence
from optparse import OptionParser
from pyparsing import ParseException

import extractor
from extractor.compound import FlatCompoundExtractor
from lru import LRUFileCache

def open_makedirs(path):
    try:
        return open(path, 'a')
    except IOError as err:
        if err.errno != errno.ENOENT: raise err
        if '/' not in path: raise err
        os.makedirs(os.path.dirname(path))
        return open(path, 'a')

import io

class RecordWriter(io.IOBase):
    def __init__(self, buffer, output_separator):
        self.buffer = buffer
        self.output_separator = output_separator

    @property
    def name(self):
        return self.buffer.name

    @property
    def closed(self):
        return self.buffer.closed

    def fileno(self):
        self.buffer.fileno()

    def flush(self):
        self.buffer.flush()

    def isatty(self):
        self.buffer.isatty()

    def readable(self):
        return False

    def writable(self):
        return True

    def write(self, record):
        self.buffer.write(str(record) + self.output_separator)

    def close(self):
        self.buffer.close()

class App(object):
    output_separator = '\n'

    @property
    def extractor(self):
        try:
            return self._extractor
        except AttributeError:
            raise AttributeError('%r extractor not set'
                % self.__class__.__name__)

    @extractor.setter
    def extractor(self, ext):
        try:
            if isinstance(ext, basestring):
                ext = extractor.parse(ext)[0]
            elif isinstance(ext, Sequence):
                ext = FlatCompoundExtractor(extractor.parse(spec)[0]
                    for spec in ext)
            self._extractor = ext

        except ParseException as exc:
            print >>sys.stderr, "Invalid extractor:", exc
            print >>sys.stderr, exc.markInputline()
            sys.exit(1)

    def openkeyfile(self, key):
        fp = open_makedirs(key.topath())
        return RecordWriter(fp, self.output_separator)

    def records(self):
        finput = fileinput.FileInput(files=self.files,
            openhook=fileinput.hook_compressed)

        for line in finput:
            yield line.rstrip('\r\n')

class SplatApp(App):
    optparser = OptionParser()
    optparser.add_option('-v', '--verbose',
        dest='verbose', action='store_true', default=True)
    optparser.add_option('-x', '--extract',
        dest='extract', action='append', default=[])

    def __init__(self, args=None):
        self.opts, self.files = self.optparser.parse_args(args)
        self.extractor = self.opts.extract

    def __call__(self):
        if self.opts.verbose:
            counts = OrderedDict()
            paths = []

        with LRUFileCache(self.openkeyfile) as filecache:
            for record in self.records():
                key = self.extractor(record)
                filecache.use(key).write(record)
                if self.opts.verbose:
                    try:
                        counts[key] += 1
                    except KeyError:
                        counts[key] = 1
                        paths.append(filecache[key].name)

        if self.opts.verbose:
            counts = counts.values()
            fmt = '  %% %dd %%s' % len(str(max(counts)))
            for count_path in zip(counts, paths):
                print fmt % count_path

SplatApp()()

# vim:set ft=python ts=4 sw=4 et:
