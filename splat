#!/usr/bin/env pypy

import errno
import fileinput
import os
import sys
from collections import OrderedDict
from optparse import OptionParser
from pyparsing import ParseException

import extractor
from extractor.compound import FlatCompoundExtractor
from lru import LRUFileCache

def open_makedirs(path):
    try:
        return open(path, 'a')
    except IOError as err:
        if err.errno != errno.ENOENT: raise err
        if '/' not in path: raise err
        os.makedirs(os.path.dirname(path))
        return open(path, 'a')

import io

class RecordWriter(io.IOBase):
    def __init__(self, buffer, output_separator):
        self.buffer = buffer
        self.output_separator = output_separator

    @property
    def name(self):
        return self.buffer.name

    @property
    def closed(self):
        return self.buffer.closed

    def fileno(self):
        self.buffer.fileno()

    def flush(self):
        self.buffer.flush()

    def isatty(self):
        self.buffer.isatty()

    def readable(self):
        return False

    def writable(self):
        return True

    def write(self, record):
        self.buffer.write(str(record) + self.output_separator)

    def close(self):
        self.buffer.close()

class App(object):
    def __init__(self, args=None):
        self.opts, self.files = self.optparser.parse_args(args)

        try:
            self.extractor = FlatCompoundExtractor(extractor.parse(spec)[0]
                for spec in self.opts.extract)

        except ParseException as exc:
            print >>sys.stderr, "Invalid extractor:", exc
            print >>sys.stderr, exc.markInputline()
            sys.exit(1)

    def records(self):
        finput = fileinput.FileInput(files=self.files,
            openhook=fileinput.hook_compressed)

        for line in finput:
            yield line.rstrip('\r\n')

class SplatApp(App):
    output_separator = '\n'
    nonefile = '__default__'

    optparser = OptionParser()
    optparser.add_option('-v', '--verbose',
        dest='verbose', action='store_true', default=True)
    optparser.add_option('-x', '--extract',
        dest='extract', action='append', default=[])

    def openkeyfile(self, key):
        path = os.path.sep.join(
            self.nonefile if v is None else str(v) for v in key)
        return RecordWriter(open_makedirs(path), self.output_separator)

    def __call__(self):
        if self.opts.verbose:
            counts = OrderedDict()
            paths = []

        with LRUFileCache(self.openkeyfile) as filecache:
            for record in self.records():
                key = self.extractor(record)
                fp = filecache.use(key)
                fp.write(record)
                if self.opts.verbose:
                    try:
                        counts[key] += 1
                    except KeyError:
                        counts[key] = 1
                        paths.append(fp.name)

        if self.opts.verbose:
            counts = counts.values()
            fmt = '  %% %dd %%s' % len(str(max(counts)))
            for count_path in zip(counts, paths):
                print fmt % count_path

SplatApp()()

# vim:set ft=python ts=4 sw=4 et:
