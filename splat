#!/usr/bin/env pypy

import errno
import fileinput
import os
import sys
from collections import OrderedDict
from optparse import OptionParser
from pyparsing import ParseException

import extractor
from extractor.compound import FlatCompoundExtractor
from lru import LRUFileCache

def open_makedirs(path):
    try:
        return open(path, 'a')
    except IOError as err:
        if err.errno != errno.ENOENT: raise err
        if '/' not in path: raise err
        os.makedirs(os.path.dirname(path))
        return open(path, 'a')

class App(object):
    def __init__(self, args=None):
        self.opts, self.files = self.optparser.parse_args(args)

        try:
            self.extractor = FlatCompoundExtractor(extractor.parse(spec)[0]
                for spec in self.opts.extract)

        except ParseException as exc:
            print >>sys.stderr, "Invalid extractor:", exc
            print >>sys.stderr, exc.markInputline()
            sys.exit(1)

    def records(self):
        finput = fileinput.FileInput(files=self.files,
            openhook=fileinput.hook_compressed)

        for line in finput:
            yield line.rstrip('\r\n')

class SplatApp(App):
    optparser = OptionParser()
    optparser.set_defaults(
        output_separator='\n',
        nonefile='__default__')
    optparser.add_option('-v', '--verbose',
        dest='verbose', action='store_true', default=True)
    optparser.add_option('-x', '--extract',
        dest='extract', action='append', default=[])

    def __call__(self):
        if self.opts.verbose:
            counts = OrderedDict()
            paths = []

        fmt = '%s' + self.opts.output_separator
        with LRUFileCache(lambda key: open_makedirs(os.path.sep.join(
            self.opts.nonefile if v is None else str(v) for v in key))) as filecache:
            for record in self.records():
                key = self.extractor(record)
                fp = filecache.use(key)
                fp.write(fmt % record)
                if self.opts.verbose:
                    try:
                        counts[key] += 1
                    except KeyError:
                        counts[key] = 1
                        paths.append(fp.name)

        if self.opts.verbose:
            counts = counts.values()
            fmt = '  %% %dd %%s' % len(str(max(counts)))
            for count_path in zip(counts, paths):
                print fmt % count_path

SplatApp()()

# vim:set ft=python ts=4 sw=4 et:
