#!/usr/bin/env pypy

import errno
import fileinput
import os
import sys
from collections import OrderedDict
from optparse import OptionParser
from pyparsing import ParseException

import extractor
from extractor.compound import FlatCompoundExtractor
from lru import LRUFileCache

def open_makedirs(path):
    try:
        return open(path, 'a')
    except IOError as err:
        if err.errno != errno.ENOENT: raise err
        if '/' not in path: raise err
        os.makedirs(os.path.dirname(path))
        return open(path, 'a')

optparser = OptionParser()
optparser.set_defaults(
    output_separator='\n',
    nonefile='__default__')
optparser.add_option('-v', '--verbose',
    dest='verbose', action='store_true', default=True)
optparser.add_option('-x', '--extract',
    dest='extract', action='append', default=[])
opts, files = optparser.parse_args()

try:
    ext = FlatCompoundExtractor(extractor.parse(spec)[0]
        for spec in opts.extract)

except ParseException as exc:
    print >>sys.stderr, "Invalid extractor:", exc
    print >>sys.stderr, exc.markInputline()
    sys.exit(1)

finput = fileinput.FileInput(
    files=files,
    openhook=fileinput.hook_compressed)

records = (line.rstrip('\r\n') for line in finput)

if opts.verbose:
    counts = OrderedDict()
    paths = []

fmt = '%s' + opts.output_separator
with LRUFileCache(lambda key: open_makedirs(os.path.sep.join(
    opts.nonefile if v is None else str(v) for v in key))) as filecache:
    for record in records:
        key = ext(record)
        fp = filecache.use(key)
        fp.write(fmt % record)
        if opts.verbose:
            try:
                counts[key] += 1
            except KeyError:
                counts[key] = 1
                paths.append(fp.name)

if opts.verbose:
    counts = counts.values()
    fmt = '  %% %dd %%s' % len(str(max(counts)))
    for count_path in zip(counts, paths):
        print fmt % count_path

# vim:set ft=python ts=4 sw=4 et:
